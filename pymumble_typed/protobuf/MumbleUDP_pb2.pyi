"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Copyright 2022-2023 The Mumble Developers. All rights reserved.
Use of this source code is governed by a BSD-style license
that can be found in the LICENSE file at the root of the
Mumble source tree or at <https://www.mumble.info/LICENSE>.
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import typing

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class Audio(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TARGET_FIELD_NUMBER: builtins.int
    CONTEXT_FIELD_NUMBER: builtins.int
    SENDER_SESSION_FIELD_NUMBER: builtins.int
    FRAME_NUMBER_FIELD_NUMBER: builtins.int
    OPUS_DATA_FIELD_NUMBER: builtins.int
    POSITIONAL_DATA_FIELD_NUMBER: builtins.int
    VOLUME_ADJUSTMENT_FIELD_NUMBER: builtins.int
    IS_TERMINATOR_FIELD_NUMBER: builtins.int
    target: builtins.int
    """When this audio is sent by the client to the server, this is set to the target of the audio data. This target
    is a number in the range [0, 2^{32} - 1], where 0 means "normal talking", 2^{5} - 1 means "server loopback"
    and all other targets are understood as shout/whisper targets that have previously been registered via a
    VoiceTarget message (via TCP).
    """
    context: builtins.int
    """When this audio is sent by the server to the client, this indicates the context in which the audio has been sent.
    0: Normal speech
    1: Shout to channel
    2: Whisper to user
    3: Received via channel listener
    """
    sender_session: builtins.int
    """The session of the client (sender) this audio was originally sent from. This field is not required when sending
    audio to the server, but will always be set when receiving audio from the server.
    """
    frame_number: builtins.int
    """The number of the first contained audio frame (indicating the position of that frame in the overall audio stream)"""
    opus_data: builtins.bytes
    """The actual voice data payload in the Opus format."""
    volume_adjustment: builtins.float
    """A volume adjustment determined by the server for this audio packet. It is up to the client to apply this adjustment to
    the resulting audio (or not). Note: A value of 0 means that this field is unset.
    """
    is_terminator: builtins.bool
    """Note that we skip the field indices up to (including) 15 in order to have them available for future extensions of the
    protocol with fields that are encountered very often. The reason is that all field indices <= 15 require only a single
    byte of encoding overhead, whereas the once > 15 require (at least) two bytes. The reason lies in the Protobuf encoding
    scheme that uses 1 bit for a varint continuation flag, 3 bit to encode a field's type and the remaining 4 bit of the
    first byte are thus available for the field index. Therefore the first 2^4 = 16 field indices (aka values 0 to 15) can
    be encoded using only a single byte. For details see https://developers.google.com/protocol-buffers/docs/encoding

    A flag indicating whether this audio packet represents the end of transmission for the current audio stream
    """
    @property
    def positional_data(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """Optional positional data indicating the speaker's position in a virtual world (in meters). This "list" is really
        expected to be an array of size 3 containing the X, Y and Z coordinates of the position (in that order).
        """

    def __init__(
        self,
        *,
        target: builtins.int = ...,
        context: builtins.int = ...,
        sender_session: builtins.int = ...,
        frame_number: builtins.int = ...,
        opus_data: builtins.bytes = ...,
        positional_data: collections.abc.Iterable[builtins.float] | None = ...,
        volume_adjustment: builtins.float = ...,
        is_terminator: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["Header", b"Header", "context", b"context", "target", b"target"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["Header", b"Header", "context", b"context", "frame_number", b"frame_number", "is_terminator", b"is_terminator", "opus_data", b"opus_data", "positional_data", b"positional_data", "sender_session", b"sender_session", "target", b"target", "volume_adjustment", b"volume_adjustment"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["Header", b"Header"]) -> typing.Literal["target", "context"] | None: ...

global___Audio = Audio

@typing.final
class Ping(google.protobuf.message.Message):
    """*
    Ping message for checking UDP connectivity (and roundtrip ping) and potentially obtaining further server
    details (e.g. version).
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TIMESTAMP_FIELD_NUMBER: builtins.int
    REQUEST_EXTENDED_INFORMATION_FIELD_NUMBER: builtins.int
    SERVER_VERSION_V2_FIELD_NUMBER: builtins.int
    USER_COUNT_FIELD_NUMBER: builtins.int
    MAX_USER_COUNT_FIELD_NUMBER: builtins.int
    MAX_BANDWIDTH_PER_USER_FIELD_NUMBER: builtins.int
    timestamp: builtins.int
    """Timestamp as encoded by the client. A server is not supposed to attempt to decode or modify this field. Therefore,
    clients may choose an arbitrary format for this timestamp (as long as it fits into a uint64 field).
    """
    request_extended_information: builtins.bool
    """A flag set by the sending client, if it wants to obtain additional information about the server."""
    server_version_v2: builtins.int
    """Below are the fields for the "additional information" that are filled out by the server on request.

    The version of the server in the new version format.
    The new protobuf Ping packet introduced with 1.5 drops support for the legacy version format
    since both server and client have to support this new format.
    (See https://github.com/mumble-voip/mumble/issues/5827)
    """
    user_count: builtins.int
    """The amount of users currently connected to the server"""
    max_user_count: builtins.int
    """The maximum amount of users permitted on this server"""
    max_bandwidth_per_user: builtins.int
    """The maximum bandwidth each user is allowed to use for sending audio to the server"""
    def __init__(
        self,
        *,
        timestamp: builtins.int = ...,
        request_extended_information: builtins.bool = ...,
        server_version_v2: builtins.int = ...,
        user_count: builtins.int = ...,
        max_user_count: builtins.int = ...,
        max_bandwidth_per_user: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["max_bandwidth_per_user", b"max_bandwidth_per_user", "max_user_count", b"max_user_count", "request_extended_information", b"request_extended_information", "server_version_v2", b"server_version_v2", "timestamp", b"timestamp", "user_count", b"user_count"]) -> None: ...

global___Ping = Ping
